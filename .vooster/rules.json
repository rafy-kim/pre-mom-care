{
  "rules": [
    {
      "type": "prd",
      "content": "## **PRD: 예비맘, 안심 톡 (PreMom CareChat)**\n\n### **단계 1: 제품 정의 (변경 없음)**\n\n* **제품명:** 예비맘, 안심 톡  \n* **프로젝트명:** PreMom CareChat  \n* **제품 정의:** 임신/출산 과정에서 발생하는 다양한 신체적, 심리적 변화에 대해 걱정이 많은 **예비 부모**를 위한 AI 챗봇 서비스입니다. 전문 지식(유튜브, 서적 등)을 RAG(Retrieval-Augmented Generation) 기술로 학습하여, 신뢰할 수 있는 출처를 기반으로 따뜻하고 공감적인 조언을 24시간 제공합니다.  \n* **제품의 목적 및 가치:**  \n  * **목적:** 넘쳐나는 불확실한 정보 속에서 예비 부모들이 느끼는 불안감을 해소하고, 검증된 전문가의 지식에 쉽고 빠르게 접근할 수 있도록 돕는다.  \n  * **핵심 가치:** 신뢰성, 공감, 접근성. 정확한 정보와 따뜻한 위로를 통해 예비 부모의 건강하고 안정적인 임신 기간을 지원한다.\n\n### ---\n\n**단계 2: PRD 작성**\n\n### **1\\. 제품 개요 (변경 없음)**\n\n1.1. 개발 배경  \n임신 기간 동안 예비 부모들은 다양한 신체적, 감정적 변화를 겪으며 사소한 증상 하나에도 큰 불안감을 느낍니다. 인터넷 커뮤니티나 SNS를 통해 정보를 얻으려 하지만, 검증되지 않은 정보와 상업적 광고가 많아 오히려 혼란이 가중되는 경우가 많습니다. 병원에 문의하기에는 사소하게 느껴지는 질문들이 많아, 심리적 고립감과 불안을 해소할 창구가 부족한 실정입니다.  \n**1.2. 해결하려는 문제**\n\n* **정보의 비대칭성:** 전문적이고 신뢰도 높은 임신/출산 정보에 대한 접근성이 낮습니다.  \n* **심리적 불안감:** 사소한 질문도 편하게 할 곳이 없어 불안감이 증폭됩니다.  \n* **정보의 신뢰도 문제:** 온라인상의 부정확하고 상업적인 정보로 인한 혼란과 오해가 발생합니다.\n\n1.3. 가치 제안  \n\"예비맘, 안심 톡\"은 신뢰할 수 있는 전문가들의 지식을 기반으로, 언제 어디서든 예비 부모의 질문에 답변해 주는 든든한 AI 친구입니다. 단순히 정보를 전달하는 것을 넘어, 사용자의 불안한 마음에 공감하고 따뜻한 위로를 건네며, 모든 답변에 명확한 출처를 제시하여 최고의 신뢰도를 제공합니다.\n\n### **2\\. 대상 사용자 (User Persona) \\- '예비 아빠' 추가**\n\n* **초산 예비맘, 김민지 (32세)**  \n  * **상황:** 첫 임신 12주차. 사소한 신체 변화에도 '혹시 아기에게 문제가 있는 건 아닐까?' 하는 걱정이 많습니다. 인터넷으로 정보를 찾아보지만, 상반된 이야기가 많아 더 불안해집니다.  \n  * **니즈:** 기초적이지만 신뢰할 수 있는 정보와 함께, 자신의 걱정이 정상적인 것인지에 대한 심리적 안정을 얻고 싶어 합니다.  \n* **경산 예비맘, 박서연 (35세)**  \n  * **상황:** 둘째 임신 28주차. 첫째 때와 다른 증상이 나타나 궁금하지만, 육아와 일을 병행하느라 병원에 갈 시간을 내기 어렵습니다. 첫째 때의 경험이 있지만, 기억이 가물가물하고 새로운 궁금증이 생깁니다.  \n  * **니즈:** 특정 증상이나 상황에 대해 빠르고 정확한 답변을 원하며, 신뢰할 수 있는 출처를 통해 정보를 재확인하고 싶어 합니다.  \n* **\\[신규\\] 예비 아빠, 최준호 (34세)**  \n  * **상황:** 아내의 첫 임신을 함께 겪고 있는 예비 아빠. 아내를 돕고 싶지만 임신 과정에 대해 아는 것이 거의 없어 막막합니다. 아내가 힘들어할 때 어떻게 위로하고 도와줘야 할지 구체적인 방법을 알고 싶어 합니다.  \n  * **니즈:** 임신 중인 아내의 신체적, 심리적 변화를 이해하고, 아빠로서 실질적으로 도울 수 있는 역할과 준비사항에 대한 정보를 얻고 싶어 합니다.\n\n### **3\\. 사용자 흐름 (User Flow) \\- 온보딩 및 로그인 흐름 추가**\n\n**3.1. \\[신규\\] 첫 사용자 진입 및 정보 입력 흐름 (Onboarding Flow)**\n\n1. **\\[진입\\]** 사용자가 앱을 최초로 실행하면 서비스의 핵심 가치를 설명하는 간략한 환영 페이지를 확인한다.  \n2. **\\[정보 입력 요청\\]** \"더 정확한 맞춤형 답변을 위해 아기에 대한 정보를 알려주세요\\!\" 와 같은 안내와 함께 정보 입력 페이지로 이동한다.  \n3. **\\[정보 입력\\]** 사용자는 다음 항목들을 입력하거나 선택한다.  \n   * **아기 태명:** (텍스트 입력)  \n   * **출산 예정일:** (캘린더 선택)  \n   * **아기 성별:** (남아 / 여아 / 아직 몰라요)  \n   * **나의 관계:** (엄마 / 아빠)  \n4. **\\[완료 및 개인화\\]** 정보 입력이 완료되면, 해당 정보를 바탕으로 개인화된 환영 메시지와 함께 메인 챗봇 화면으로 진입한다. (예: \"튼튼이(태명) 아빠, 안녕하세요\\! 무엇이든 물어보세요.\")\n\n**3.2. \\[신규\\] 게스트 모드 및 로그인 유도 흐름**\n\n1. **\\[게스트 모드 대화\\]** 사용자는 별도 로그인 없이 온보딩 후 즉시 챗봇과 대화를 시작할 수 있다. (게스트 상태)  \n2. **\\[로그인 유도\\]** 사용자가 대화를 종료하거나, 일정 횟수(예: 3\\~5회) 이상 질문했을 때, 아래와 같은 이점을 설명하며 로그인을 유도하는 비간섭적인(non-intrusive) UI가 표시된다.  \n   * **안내 문구:** \"소중한 대화 기록을 안전하게 저장하고, 다른 기기에서도 확인하려면 로그인이 필요해요. 간편하게 로그인하고 모든 기록을 지켜보세요\\!\"  \n3. **\\[로그인 또는 유지\\]** 사용자는 '카카오/구글 등으로 간편 로그인'을 선택하여 계정을 생성하거나, '나중에 하기'를 선택하여 게스트 모드를 유지할 수 있다. 로그인 시 기존 대화 기록은 해당 계정에 즉시 동기화된다.\n\n**3.3. 일반 질의응답 흐름 (기존과 동일)**\n\n* 사용자가 질문을 입력하면, AI가 RAG 엔진을 통해 신뢰성 있는 답변을 출처와 함께 제공한다.\n\n### **4\\. 기능 요구사항 (업데이트)**\n\n| 기능명 | 상세 설명 | 개발 난이도 | 우선순위 |\n| :---- | :---- | :---- | :---- |\n| **핵심 기능** |  |  |  |\n| **\\[신규\\]** 1\\. 초기 사용자 정보 입력 (Onboarding) | \\- 첫 사용 시 아기 태명, 출산 예정일, 성별, 사용자 관계(부/모)를 입력받는 기능.\\<br\\>- 입력된 정보는 챗봇의 개인화된 응대에 활용됨. | 쉬움 | **상** |\n| **\\[신규\\]** 2\\. 게스트 모드 및 소셜 로그인 | \\- 별도 가입 없이 서비스를 즉시 이용할 수 있는 게스트 모드 제공.\\<br\\>- 대화 기록 동기화 및 멤버십 유지를 위한 간편 소셜 로그인(카카오, 구글 등) 기능. | 보통 | **상** |\n| 3\\. AI 챗봇 인터페이스 | 사용자가 질문을 입력하고 AI의 답변을 확인할 수 있는 기본적인 채팅 UI. | 쉬움 | **상** |\n| 4\\. RAG 기반 질의응답 엔진 | 전문가의 큐레이션된 데이터를 기반으로 사용자 질문에 가장 적합한 정보를 검색하고 생성형 AI가 자연스러운 답변을 생성. | 어려움 | **상** |\n| 5\\. 출처 표시 기능 | AI가 답변을 생성할 때 참고한 원본 데이터(영상 링크, 책 제목 등)를 함께 제공. | 보통 | **상** |\n| 6\\. 공감형/안전중심 대화 모델 | 사용자의 감정을 고려한 따뜻한 어조로 답변하고, 위험 신호 감지 시 병원 방문을 최우선으로 권고하는 안전장치 포함. | 보통 | **상** |\n| **\\[우선순위 상향\\]** 7\\. 주차별 정보 추천 | **온보딩 시 입력된 출산 예정일을 기반으로**, 해당 주차에 필요한 정보나 예상 질문을 먼저 제안하는 기능. | 보통 | **상** |\n| **부가 기능** |  |  |  |\n| 8\\. 대화 기록 저장 | \\- **게스트 모드:** 기기 내에만 대화 임시 저장.\\<br\\>- **로그인 시:** 계정에 대화 기록이 귀속되어 여러 기기에서 동기화. | 쉬움 | **중** |\n| 9\\. 주요 답변 북마크 | 사용자가 중요하다고 생각하는 답변을 따로 저장하고 모아볼 수 있는 기능. | 쉬움 | **중** |\n| 10\\. 사용자 피드백 시스템 | 답변에 대한 '도움돼요/안돼요' 평가를 받아 AI 모델 개선에 활용하는 기능. | 보통 | **하** |\n| 11\\. 푸시 알림 | 주차별 주요 정보, 새로운 전문가 콘텐츠 업데이트 등을 알림으로 제공. (사용자 동의 기반) | 보통 | **하** |\n| 12\\. 커뮤니티 연동 | 비슷한 주차의 예비 부모들과 소통할 수 있는 안전한 익명 커뮤니티 기능. (장기적인 확장 계획) | 어려움 | **하** |\n\n",
      "writedAt": "2025-08-12T02:11:41.717Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-12T02:11:41.717Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-08-12T02:11:41.717Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-12T02:11:41.717Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-08-12T02:11:41.717Z"
    }
  ]
}