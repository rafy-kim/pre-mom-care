## **📝 기본 채팅 기능 명세서**

### **1\. 프론트엔드 기능명세서**

#### **1.1. 화면 레이아웃 및 디자인 명세**

**1\) 페이지: 메인 챗봇 페이지 (app/chat/page.tsx)**

* **개요**: 사용자가 AI와 대화하는 주 화면입니다. 서버 컴포넌트로 구현하여, 쿠키에 저장된 사용자 정보를 읽어 하위 클라이언트 컴포넌트로 전달합니다.  
* **레이아웃**:  
  * 화면 전체를 차지하며, 상단에 Header, 중앙에 ChatUI, 하단에 ChatInput 컴포넌트가 수직으로 배치됩니다.

**2\) 컴포넌트: 공통 헤더 (components/layout/Header.tsx)**

* **개요**: 온보딩 정보를 기반으로 개인화된 환영 메시지와 D-Day를 표시합니다.  
* **명세**:  
  * 온보딩 시 입력한 '태명'과 '관계'를 받아 "튼튼이 아빠, 안녕하세요\!"와 같은 환영 문구를 표시합니다. 1  
  * '출산 예정일' 정보를 기반으로 "D-180"과 같이 남은 날짜를 계산하여 표시합니다. 2  
  * 우측에는 북마크와 설정 아이콘이 포함된 ShadCN/Button이 배치됩니다 (아이콘 버튼의 실제 기능은 추후 구현). 3

**3\) 컴포넌트: 채팅 UI (app/chat/ChatUI.tsx)**

* **속성**: Client Component ('use client')  
* **개요**: 채팅과 관련된 모든 상태(메시지 목록, 입력 값 등)와 로직을 관리하는 핵심 컨테이너 컴포넌트입니다.  
* **상태 관리 (useState)**:  
  * messages: 채팅 메시지 전체 목록을 관리하는 배열. 각 요소는 { id, sender: 'user' | 'ai' | 'loading', text, source? }와 같은 구조를 가집니다.  
  * input: 사용자의 입력 메시지를 관리하는 문자열.  
* **초기 상태**:  
  * 컴포넌트가 마운트되면, messages 상태는 AI의 첫 환영 메시지와 추천 질문 카드를 포함하여 초기화됩니다. 4  
  * 예: \[{ id: 1, sender: 'ai', text: '안녕하세요\! 무엇이든 물어보세요.' }\]

**4\) 컴포넌트: 메시지 목록 (app/chat/ChatMessages.tsx)**

* **개요**: ChatUI로부터 messages 배열을 props로 받아 실제 대화 내용을 화면에 렌더링합니다.  
* **명세**:  
  * messages 배열을 순회하며 sender 타입에 따라 다른 스타일의 메시지 버블을 렌더링합니다.  
  * sender \=== 'user': 사용자 메시지 버블 (오른쪽 정렬)  
  * sender \=== 'ai': AI 메시지 버블 (왼쪽 정렬). 메시지 하단에는 출처가 표시됩니다. 5  
  * sender \=== 'loading': AI가 답변을 생성 중임을 알리는 로딩 인디케이터를 표시합니다. 6 (예: 깜빡이는 점 3개)  
  * 새 메시지가 추가되면 대화 영역이 자동으로 최하단으로 스크롤됩니다.

**5\) 컴포넌트: 메시지 입력 폼 (app/chat/ChatInput.tsx)**

* **개요**: 사용자가 메시지를 입력하고 전송하는 하단 입력 영역입니다.  
* **ShadCN 컴포넌트**: Input, Button  
* **위치**: components/ui/input.tsx, components/ui/button.tsx  
* **명세**:  
  * Input 컴포넌트는 placeholder로 "무엇이든 물어보세요..."를 가집니다. 7  
  * 사용자가 메시지를 입력하고 '전송' Button을 클릭하거나 Enter 키를 누르면, 부모 컴포넌트(ChatUI)에 정의된 메시지 전송 함수를 호출합니다.

#### **1.2. 사용자 흐름 및 상호작용**

1. 사용자가 app/chat 페이지에 진입하면, 개인화된 헤더와 초기 환영 메시지를 확인합니다.  
2. 사용자가 ChatInput에 메시지를 입력하고 '전송' 버튼을 클릭합니다.  
3. ChatUI의 메시지 전송 핸들러 함수가 실행됩니다. a. 현재 input 상태 값을 { id: ..., sender: 'user', ... } 객체로 만들어 messages 배열에 추가합니다. b. 사용자 입력창을 즉시 비웁니다. c. AI 응답을 기다리는 동안, { id: ..., sender: 'loading' } 객체를 messages 배열에 추가합니다. d. setTimeout을 사용해 1\~2초의 지연을 시뮬레이션합니다. e. 지연 시간이 끝나면, messages 배열에서 loading 객체를 제거합니다. f. 미리 정의된 Mock 답변 { id: ..., sender: 'ai', text: '입덧 때문에 힘드시겠어요...', source: '튼튼맘의 임신출산백과' } 객체를 messages 배열에 추가합니다. 8  
4. messages 상태가 변경될 때마다 ChatMessages 컴포넌트는 화면을 다시 렌더링하여 대화의 변화를 실시간으로 보여줍니다.

#### **1.3. API 연동**

* **해당 없음**: 이 단계에서는 클라이언트 사이드에서 모든 로직을 처리하며, 실제 백엔드 API 호출은 발생하지 않습니다. AI의 응답은 사전에 정의된 Mock 데이터로 대체됩니다.

#### **1.4. 테스트 항목**

* \[ \] 온보딩 시 입력한 정보가 헤더에 정확히 표시되는지 확인합니다.  
* \[ \] 메시지 전송 시, 사용자의 메시지가 대화창 오른쪽에 즉시 나타나는지 확인합니다.  
* \[ \] 메시지 전송 직후, 로딩 인디케이터가 대화창 왼쪽에 나타나는지 확인합니다. 9  
* \[ \] 일정 시간 후, 로딩 인디케이터가 사라지고 Mock AI 답변이 대화창 왼쪽에 나타나는지 확인합니다.  
* \[ \] AI 답변 하단에 출처 정보가 올바르게 표시되는지 확인합니다. 10  
* \[ \] 메시지 전송 후 입력창이 깨끗하게 비워지는지 확인합니다.

### **2\. 백엔드 기능명세서**

* **해당 없음**: '기본 채팅 기능' 구현 단계에서는 백엔드 API 및 데이터베이스 로직이 필요하지 않습니다. 백엔드의 역할은 온보딩 단계에서 쿠키에 저장된 사용자 정보를 읽어 초기 페이지를 렌더링하는 것에 한정됩니다.

---

이상으로 기본 채팅 기능에 대한 명세서 작성을 마칩니다.  
검토 후 피드백이 있으시면 말씀해주시고, 없으시면 다음 단계의 기능명세서 작성을 진행하겠습니다.

1. **AI 챗봇 연동 및 로그인**  
2. **대화 기록 관리 및 부가 기능**